/*
 * Copyright (c) 1999-2013 Mark D. Hill and David A. Wood
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*CHANGES - Added clockEdge()
          msg.Addr --> msg.addr*/

machine(L1Cache, "MESI Directory L1 Cache CMP")
 : RCTable * rcc;
   Sequencer * sequencer;
   CacheMemory * L1Icache;
   CacheMemory * L1Dcache;
   Prefetcher * prefetcher;
   int l2_select_num_bits;
   Cycles l1_request_latency := 2;
   Cycles l1_response_latency := 2;
   Cycles to_l2_latency := 1;
   bool send_evictions;
   bool enable_prefetch := "False";

   // Message Queues
   // From this node's L1 cache TO the network

   // a local L1 -> this L2 bank, currently ordered with directory forwarded requests
   MessageBuffer * requestFromL1Cache, network="To", virtual_network="0",
        ordered="false", vnet_type="request";

   // a local L1 -> this L2 bank
   MessageBuffer * responseFromL1Cache, network="To", virtual_network="1",
        ordered="false", vnet_type="response";

   MessageBuffer * unblockFromL1Cache, network="To", virtual_network="2",
        ordered="false", vnet_type="unblock";


   // To this node's L1 cache FROM the network
   // a L2 bank -> this L1
   MessageBuffer * requestToL1Cache, network="From", virtual_network="2",
        ordered="false", vnet_type="request";

   // a L2 bank -> this L1
   MessageBuffer * responseToL1Cache, network="From", virtual_network="1",
        ordered="false", vnet_type="response";

/*******************************************/
// Request Buffer for prefetches
  MessageBuffer * optionalQueue;

  // Buffer for requests generated by the processor core.
  MessageBuffer * mandatoryQueue;
{
  // STATES
  state_declaration(State, desc="Cache states", default="L1Cache_State_I") {
    // Base states
    NP, AccessPermission:Invalid, desc="Not present in either cache";
    I, AccessPermission:Invalid, desc="a L1 cache entry Idle";
    S, AccessPermission:Read_Only, desc="a L1 cache entry Shared";
    E, AccessPermission:Read_Only, desc="a L1 cache entry Exclusive";
    M, AccessPermission:Read_Write, desc="a L1 cache entry Modified", format="!b";

    // Transient States
    IS, AccessPermission:Busy, desc="L1 idle, issued GETS, have not seen response yet";
    IM, AccessPermission:Busy, desc="L1 idle, issued GETX, have not seen response yet";
    SM, AccessPermission:Read_Only, desc="L1 idle, issued GETX, have not seen response yet";
    IS_I, AccessPermission:Busy, desc="L1 idle, issued GETS, saw Inv before data because directory doesn't block on GETS hit";

    M_I, AccessPermission:Busy, desc="L1 replacing, waiting for ACK";
    SINK_WB_ACK, AccessPermission:Busy, desc="This is to sink WB_Acks from L2";

    // Transient States in which block is being prefetched
    PF_IS, AccessPermission:Busy, desc="Issued GETS, have not seen response yet";
    PF_IM, AccessPermission:Busy, desc="Issued GETX, have not seen response yet";
    PF_SM, AccessPermission:Busy, desc="Issued GETX, received data, waiting for acks";
    PF_IS_I, AccessPermission:Busy, desc="Issued GETs, saw inv before data";
  }

  // EVENTS
  enumeration(Event, desc="Cache events") {
    // L1 events
    Load,            desc="Load request from the home processor";
    Ifetch,          desc="I-fetch request from the home processor";
    Store,           desc="Store request from the home processor";

    Inv,           desc="Invalidate request from L2 bank";

    // internal generated request
    L1_Replacement,  desc="L1 Replacement", format="!r";

    // other requests
    Fwd_GETX,   desc="GETX from other processor";
    Fwd_GETS,   desc="GETS from other processor";
    Fwd_GET_INSTR,   desc="GET_INSTR from other processor";

    Data,       desc="Data for processor";
    RCC_Exclusive,       desc="Data for processor";
    DataS_fromL1,       desc="data for GETS request, need to unblock directory";
    Data_all_Acks,       desc="Data for processor, all acks";

    Ack,        desc="Ack for processor";
    Ack_all,      desc="Last ack for processor";

    WB_Ack,        desc="Ack for replacement";

    PF_Load,    desc="load request from prefetcher";
    PF_Ifetch,  desc="instruction fetch request from prefetcher";
    PF_Store,   desc="exclusive load request from prefetcher";
    
    RCC_allocate, desc="";  // Ravali -- Adding event RCC_allocate
    RCC_HIT, desc=""; //Ravali -- Adding missing event -- Nirvedh mdfy have to use this to actually reap benifit from RCTABLE
    RCC_Inv, desc=""; //Ravali -- Adding missing event
  }

  // TYPES

  // CacheEntry
  structure(Entry, desc="...", interface="AbstractCacheEntry" ) {
    State CacheState,        desc="cache state";
    DataBlock DataBlk,       desc="data for the block";
    bool Dirty, default="false",   desc="data is dirty";
    bool isPrefetch, desc="Set if this block was prefetched";
  }

  // TBE fields
  structure(TBE, desc="...") {
    Addr addr,              desc="Physical address for this TBE";
    State TBEState,        desc="Transient state";
    DataBlock DataBlk,                desc="Buffer for the data block";
    bool Dirty, default="false",   desc="data is dirty";
    bool isPrefetch,       desc="Set if this was caused by a prefetch";
    int pendingAcks, default="0", desc="number of pending acks";
  }

  structure(TBETable, external="yes") {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
  }

  TBETable TBEs, template="<L1Cache_TBE>", constructor="m_number_of_TBEs";
  
  /*structure(RCTable, external="yes") {
    //RCTable(const Params *p);
    ~RCTable();
    void init();
    int test(int a) const;
    
    void allocate(Addr, int, int); //int state
    void allocate_l2(Addr, MachineID); //int state=0); // *CHECK* state
    int getRCCL1State(Addr);
    void setRCCL1State(Addr, int);//int state
    int getGranularity(Addr);
    Addr getMask(Addr);
    NetDest getSharers(Addr);
    void addSharer(Addr, MachineID); // The build files tend to use const MachineId& but our RubySlicc.sm does not support this
    void removeSharer(Addr, MachineID);
    void clearSharers(Addr);
    void split(Addr);
    void splitRCC_l2(Addr,MachineID); 
    bool isPresent_RCC(Addr);
  }
  RCTable rcc;*/
  
  int l2_select_low_bit, default="RubySystem::getBlockSizeBits()";

  Tick clockEdge();
  Cycles ticksToCycles(Tick t);
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpBuffers(Addr a);
  void profileMsgDelay(int virtualNetworkType, Cycles c);

  // inclusive cache returns L1 entries only
  Entry getCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Dcache_entry := static_cast(Entry, "pointer", L1Dcache[addr]);
    if(is_valid(L1Dcache_entry)) {
      return L1Dcache_entry;
    }

    Entry L1Icache_entry := static_cast(Entry, "pointer", L1Icache[addr]);
    return L1Icache_entry;
  }

  Entry getL1DCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Dcache_entry := static_cast(Entry, "pointer", L1Dcache[addr]);
    return L1Dcache_entry;
  }

  Entry getL1ICacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Icache_entry := static_cast(Entry, "pointer", L1Icache[addr]);
    return L1Icache_entry;
  }

  State getState(TBE tbe, Entry cache_entry, Addr addr) {
    assert((L1Dcache.isTagPresent(addr) && L1Icache.isTagPresent(addr)) == false);

    if(is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.CacheState;
    }
    return State:NP;
  }

  void setState(TBE tbe, Entry cache_entry, Addr addr, State state) {
    assert((L1Dcache.isTagPresent(addr) && L1Icache.isTagPresent(addr)) == false);

    // MUST CHANGE
    if(is_valid(tbe)) {
      tbe.TBEState := state;
    }

    if (is_valid(cache_entry)) {
      cache_entry.CacheState := state;
    }
  }

  AccessPermission getAccessPermission(Addr addr) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      //DPRINTF(RubySlicc, "%s\n", L1Cache_State_to_permission(tbe.TBEState));
      return L1Cache_State_to_permission(tbe.TBEState);
    }

    Entry cache_entry := getCacheEntry(addr);
    if(is_valid(cache_entry)) {
      //DPRINTF(RubySlicc, "%s\n", L1Cache_State_to_permission(cache_entry.CacheState));
      return L1Cache_State_to_permission(cache_entry.CacheState);
    }

    //DPRINTF(RubySlicc, "%s\n", AccessPermission:NotPresent);
    return AccessPermission:NotPresent;
  }

  void functionalRead(Addr addr, Packet *pkt) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      testAndRead(addr, tbe.DataBlk, pkt);
    } else {
      testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);
    }
  }

  int functionalWrite(Addr addr, Packet *pkt) {
    int num_functional_writes := 0;

    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.DataBlk, pkt);
      return num_functional_writes;
    }

    num_functional_writes := num_functional_writes +
        testAndWrite(addr, getCacheEntry(addr).DataBlk, pkt);
    return num_functional_writes;
  }

  void setAccessPermission(Entry cache_entry, Addr addr, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.changePermission(L1Cache_State_to_permission(state));
    }
  }



  Event mandatory_request_type_to_event(RubyRequestType type) {  //Nirvedh-mdfy
    if (type == RubyRequestType:LD) {
	DPRINTF(RubySlicc, "it does get a load request\n");  
      return Event:Load;
    } else if (type == RubyRequestType:IFETCH) {
      DPRINTF(RubySlicc, "it does get a ifetch request\n");    
      return Event:Ifetch;
    } else if ((type == RubyRequestType:ST) || (type == RubyRequestType:ATOMIC)) {
	DPRINTF(RubySlicc, "it does get a store request\n");  
      return Event:Store;
    } else {
      error("Invalid RubyRequestType");
    }
  }

  Event prefetch_request_type_to_event(RubyRequestType type) {
      if (type == RubyRequestType:LD) {
          return Event:PF_Load;
      } else if (type == RubyRequestType:IFETCH) {
          return Event:PF_Ifetch;
      } else if ((type == RubyRequestType:ST) ||
                 (type == RubyRequestType:ATOMIC)) {
          return Event:PF_Store;
      } else {
          error("Invalid RubyRequestType");
      }
  }

bool isReadState(State s){
		if(s == State:S || s == State:IS || s == State:PF_IS || s == State:S){
			return true;
		}
		return false;
	}

	bool isWriteState(State s){
		if(s == State:E || s == State:M || s == State:IM || s == State:SM || s == State:PF_IM || s == State:PF_SM){
			return true;
		}
		return false;
	}

  int getPendingAcks(TBE tbe) {
    return tbe.pendingAcks;
  }

State DavidgetRCCState(Addr addr){
	if(!rcc.isPresent_RCC(addr)){
		return State:NP;
	}
	std::string str := (rcc.getRCCL1State(addr)); 
 if (str == "NP") {
        return State:NP;
    } else if (str == "I") {
        return State:I;
    } else if (str == "S") {
        return State:S;
    } else if (str == "E") {
        return State:E;
    } else if (str == "M") {
        return State:M;
    } else if (str == "IS") {
        return State:IS;
    } else if (str == "IM") {
        return State:IM;
    } else if (str == "SM") {
        return State:SM;
    } else if (str == "IS_I") {
        return State:IS_I;
    } else if (str == "M_I") {
        return State:M_I;
    } else if (str == "SINK_WB_ACK") {
        return State:SINK_WB_ACK;
    } else if (str == "PF_IS") {
        return State:PF_IS;
    } else if (str == "PF_IM") {
        return State:PF_IM;
    } else if (str == "PF_SM") {
        return State:PF_SM;
    } else if (str == "PF_IS_I") {
        return State:PF_IS_I;
    } else {
       return State:NP;
    }

	//return string_to_L1Cache_State("NP");
	//return State:NP;
  }

  out_port(requestL1Network_out, RequestMsg, requestFromL1Cache);
  out_port(responseL1Network_out, ResponseMsg, responseFromL1Cache);
  out_port(unblockNetwork_out, ResponseMsg, unblockFromL1Cache);
  out_port(optionalQueue_out, RubyRequest, optionalQueue);


  // Prefetch queue between the controller and the prefetcher
  // As per Spracklen et al. (HPCA 2005), the prefetch queue should be
  // implemented as a LIFO structure.  The structure would allow for fast
  // searches of all entries in the queue, not just the head msg. All
  // msgs in the structure can be invalidated if a demand miss matches.
  in_port(optionalQueue_in, RubyRequest, optionalQueue, desc="...", rank = 3) {
      if (optionalQueue_in.isReady(clockEdge())) {
          peek(optionalQueue_in, RubyRequest) {
              // Instruction Prefetch
              if (in_msg.Type == RubyRequestType:IFETCH) {
                  Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
                  if (is_valid(L1Icache_entry)) {
                      // The block to be prefetched is already present in the
                      // cache. We should drop this request.
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Icache_entry, TBEs[in_msg.LineAddress]);
                  }

                  // Check to see if it is in the OTHER L1
                  Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
                  if (is_valid(L1Dcache_entry)) {
                      // The block is in the wrong L1 cache. We should drop
                      // this request.
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Dcache_entry, TBEs[in_msg.LineAddress]);
                  }

                  if (L1Icache.cacheAvail(in_msg.LineAddress)) {
                      // L1 does't have the line, but we have space for it
                      // in the L1 so let's see if the L2 has it
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Icache_entry, TBEs[in_msg.LineAddress]);
                  } else {
                      // No room in the L1, so we need to make room in the L1
                      trigger(Event:L1_Replacement,
                              L1Icache.cacheProbe(in_msg.LineAddress),
                              getL1ICacheEntry(L1Icache.cacheProbe(in_msg.LineAddress)),
                              TBEs[L1Icache.cacheProbe(in_msg.LineAddress)]);
                  }
              } else {
                  // Data prefetch
                  Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
                  if (is_valid(L1Dcache_entry)) {
                      // The block to be prefetched is already present in the
                      // cache. We should drop this request.
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Dcache_entry, TBEs[in_msg.LineAddress]);
                  }

                  // Check to see if it is in the OTHER L1
                  Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
                  if (is_valid(L1Icache_entry)) {
                      // The block is in the wrong L1. Just drop the prefetch
                      // request.
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Icache_entry, TBEs[in_msg.LineAddress]);
                  }

                  if (L1Dcache.cacheAvail(in_msg.LineAddress)) {
                      // L1 does't have the line, but we have space for it in
                      // the L1 let's see if the L2 has it
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Dcache_entry, TBEs[in_msg.LineAddress]);
                  } else {
                      // No room in the L1, so we need to make room in the L1
                      trigger(Event:L1_Replacement,
                              L1Dcache.cacheProbe(in_msg.LineAddress),
                              getL1DCacheEntry(L1Dcache.cacheProbe(in_msg.LineAddress)),
                              TBEs[L1Dcache.cacheProbe(in_msg.LineAddress)]);
                  }
              }
          }
      }
  }
/**********************************************************/


/*
************************************************************************************************************
************************************************************************************************************
******************************************************Responses to this $**********************************
************************************************************************************************************
************************************************************************************************************
*/

  // Response  L1 Network - response msg to this L1 cache
  in_port(responseL1Network_in, ResponseMsg, responseToL1Cache, rank = 2) {
    if (responseL1Network_in.isReady(clockEdge())) {
      peek(responseL1Network_in, ResponseMsg, block_on="addr") {
        assert(in_msg.Destination.isElement(machineID));

        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];

        //if(in_msg.Type == CoherenceResponseType:DATA_EXCLUSIVE) {
	if(in_msg.Type == CoherenceResponseType:RCC_ALLOCATE_EXCLUSIVE){ //David May1
          trigger(Event:RCC_Exclusive, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Type == CoherenceResponseType:DATA) {
          if ((getState(tbe, cache_entry, in_msg.addr) == State:IS ||
               getState(tbe, cache_entry, in_msg.addr) == State:IS_I ||
               getState(tbe, cache_entry, in_msg.addr) == State:PF_IS ||
               getState(tbe, cache_entry, in_msg.addr) == State:PF_IS_I) &&
              machineIDToMachineType(in_msg.Sender) == MachineType:L1Cache) {

              trigger(Event:DataS_fromL1, in_msg.addr, cache_entry, tbe);

          } else if ( (getPendingAcks(tbe) - in_msg.AckCount) == 0 ) {
            trigger(Event:Data_all_Acks, in_msg.addr, cache_entry, tbe);
          } else {
            trigger(Event:Data, in_msg.addr, cache_entry, tbe);
          }

        } else if (in_msg.Type == CoherenceResponseType:ACK) {
          if ( (getPendingAcks(tbe) - in_msg.AckCount) == 0 ) {
            trigger(Event:Ack_all, in_msg.addr, cache_entry, tbe);
          } else {
            trigger(Event:Ack, in_msg.addr, cache_entry, tbe);
          }
        } else if (in_msg.Type == CoherenceResponseType:WB_ACK) {
          trigger(Event:WB_Ack, in_msg.addr, cache_entry, tbe);
	} else if (in_msg.Type == CoherenceResponseType:RCC_ALLOCATE) { // Ravali - RCC_allocate to RCC_ALLOCATE CoherenceResponseType: RCC_ALLOCATE, event: RCC_allocate
			 trigger(Event:RCC_allocate, in_msg.addr, cache_entry, tbe);
        } else {
          error("Invalid L1 response type");
        }
      }
    }
  }

/*
************************************************************************************************************
************************************************************************************************************
******************************************************Incoming $ to this $**********************************
************************************************************************************************************
************************************************************************************************************
*/

  // Request InterChip network - request from this L1 cache to the shared L2 // David TODO Question: comment misleading? THis is in_port ... isn't this the requests between L1s? asserting in_msg.Destination = this machineID makes me think these are input messages to this L1 from other L1s
  in_port(requestL1Network_in, RequestMsg, requestToL1Cache, rank = 1) {
    if(requestL1Network_in.isReady(clockEdge())) {
      peek(requestL1Network_in, RequestMsg, block_on="addr") {
        assert(in_msg.Destination.isElement(machineID));

        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
		//David add
		bool cache_valid := is_valid(cache_entry);
		State orig_state := getState(tbe, cache_entry, in_msg.addr);
		setState(tbe, cache_entry, in_msg.addr, DavidgetRCCState(in_msg.addr)); //overwrite cache entry to do correct transition *CHECK*

        if (in_msg.Type == CoherenceRequestType:INV) {
			//David add
			if(!(cache_valid) && rcc.isPresent_RCC(in_msg.addr)){ 	//cache entry was invalid -- must restore to invalid after done
				trigger(Event:Inv, in_msg.addr, cache_entry, tbe);
				setState(tbe, cache_entry, in_msg.addr, orig_state); //restore to invalid after
			}
			else{ // do normal thing -- end David add
			
         		 trigger(Event:Inv, in_msg.addr, cache_entry, tbe);
			}
        } else if (in_msg.Type == CoherenceRequestType:GETX ||
                   in_msg.Type == CoherenceRequestType:UPGRADE) {
          // upgrade transforms to GETX due to race
			//David add
			if(!(cache_valid) && rcc.isPresent_RCC(in_msg.addr)){ 	//cache entry was invalid -- must restore to invalid after done //Ravali
				trigger(Event:Fwd_GETX, in_msg.addr, cache_entry, tbe);
				setState(tbe, cache_entry, in_msg.addr, orig_state); //restore to invalid after
			}
			else{ // do normal thing -- end David add
			
         		trigger(Event:Fwd_GETX, in_msg.addr, cache_entry, tbe);
			}
        } else if (in_msg.Type == CoherenceRequestType:GETS) {
						//David add
			if(!(cache_valid) && rcc.isPresent_RCC(in_msg.addr)){ 	//cache entry was invalid -- must restore to invalid after done //Ravali
				trigger(Event:Fwd_GETS, in_msg.addr, cache_entry, tbe);
				setState(tbe, cache_entry, in_msg.addr, orig_state); //restore to invalid after
			}
			else{ // do normal thing -- end David add
			
          		trigger(Event:Fwd_GETS, in_msg.addr, cache_entry, tbe);
			}
        } else if (in_msg.Type == CoherenceRequestType:GET_INSTR) {
			//David add
			if(!(cache_valid) && rcc.isPresent_RCC(in_msg.addr)){ 	//cache entry was invalid -- must restore to invalid after done //Ravali
				trigger(Event:Inv, in_msg.addr, cache_entry, tbe);
				setState(tbe, cache_entry, in_msg.addr, orig_state); //restore to invalid after
			}
			else{ // do normal thing -- end David add
			
         		 trigger(Event:Fwd_GET_INSTR, in_msg.addr, cache_entry, tbe);
			}
		
        } else {
          error("Invalid forwarded request type");
        }
      }
    }
  }



/*
************************************************************************************************************
************************************************************************************************************
******************************************************CPU to L1 requests ******************************************************
************************************************************************************************************
************************************************************************************************************
*/
  // Mandatory Queue betweens Node's CPU and it's L1 caches
  in_port(mandatoryQueue_in, RubyRequest, mandatoryQueue, desc="...", rank = 0) {
    if (mandatoryQueue_in.isReady(clockEdge())) {
      peek(mandatoryQueue_in, RubyRequest, block_on="LineAddress") {

        // Check for data access to blocks in I-cache and ifetchs to blocks in D-cache

        if (in_msg.Type == RubyRequestType:IFETCH) {
          // ** INSTRUCTION ACCESS ***

          Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);

			//David changes
		  //if (is_valid(L1Icache_entry){
          if (is_valid(L1Icache_entry) && rcc.isPresent_RCC(in_msg.LineAddress)) { //Ravali.
            // The tag matches for the L1, so the L1 asks the L2 for it. -- also RCC is valid, so it is ok
			 setState(TBEs[in_msg.LineAddress], L1Icache_entry, in_msg.LineAddress, DavidgetRCCState(in_msg.LineAddress)); //copy RCC state to this cache line *CHECK*
            trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.LineAddress,
                    L1Icache_entry, TBEs[in_msg.LineAddress]);
          }
           else { // not cache && RCC hit


		        // Check to see if it is in the OTHER L1
		        Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
		        if (is_valid(L1Dcache_entry)&& rcc.isPresent_RCC(in_msg.LineAddress)) { //Ravali
		          // The block is in the wrong L1, put the request on the queue to the shared L2
					//David add
					setState(TBEs[in_msg.LineAddress], L1Dcache_entry, in_msg.LineAddress, DavidgetRCCState(in_msg.LineAddress)); //copy RCC state to this cache line *CHECK*
		          trigger(Event:L1_Replacement, in_msg.LineAddress,
		                  L1Dcache_entry, TBEs[in_msg.LineAddress]);
		        }

				//in neither cache
		        if (L1Icache.cacheAvail(in_msg.LineAddress)) {
		          // L1 does't have the line, but we have space for it
		          // in the L1 so let's see if the L2 has it.


						//David add 
						//see if the fail was caused by valid RCC, but invalid cache entry -- then may be able to do RCC_GET
					if(rcc.isPresent_RCC(in_msg.LineAddress)){ //Ravali
							//Match in RCC! This means if we have permission, we can do RCC_GET
							if(mandatory_request_type_to_event(in_msg.Type) == Event:Load || mandatory_request_type_to_event(in_msg.Type) == Event:Ifetch){
								//have RCC hit, and asked for read, so we must have permission already
								trigger(Event:RCC_HIT, in_msg.LineAddress, L1Icache_entry, TBEs[in_msg.LineAddress]);
							}
							if(mandatory_request_type_to_event(in_msg.Type) == Event:Store && (isWriteState(DavidgetRCCState(in_msg.LineAddress)))){
								//have RCC hit, asked for write, and we also have permission
								trigger(Event:RCC_HIT, in_msg.LineAddress, L1Icache_entry, TBEs[in_msg.LineAddress]);					
							} /*CHECK*/
						}
					else{ //no RCC hit -- normal request

		          trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.LineAddress,
		                  L1Icache_entry, TBEs[in_msg.LineAddress]);
					}
		        } else {
		          // No room in the L1, so we need to make room in the L1
		          trigger(Event:L1_Replacement, L1Icache.cacheProbe(in_msg.LineAddress),
		                  getL1ICacheEntry(L1Icache.cacheProbe(in_msg.LineAddress)),
		                  TBEs[L1Icache.cacheProbe(in_msg.LineAddress)]);
		        }
		      }
	}else {

		      // *** DATA ACCESS ***
		      Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
		     // if (is_valid(L1Dcache_entry)) {
				if (is_valid(L1Dcache_entry) && rcc.isPresent_RCC(in_msg.LineAddress)) { //Ravali
				    // The tag matches for the L1, so the L1 ask the L2 for it
					// David add set state
					setState(TBEs[in_msg.LineAddress], L1Dcache_entry, in_msg.LineAddress, DavidgetRCCState(in_msg.LineAddress)); //copy RCC state to this cache line *CHECK*
				    trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.LineAddress,
				            L1Dcache_entry, TBEs[in_msg.LineAddress]);
					
				  } else { // not cache && RCC hit

						// Check to see if it is in the OTHER L1
						Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
						//if (is_valid(L1Icache_entry)) {
						if(is_valid(L1Icache_entry) && rcc.isPresent_RCC(in_msg.LineAddress)) { //Ravali
						  // The block is in the wrong L1, put the request on the queue to the shared L2
						  // David add set state
						  setState(TBEs[in_msg.LineAddress], L1Icache_entry, in_msg.LineAddress, DavidgetRCCState(in_msg.LineAddress)); //copy RCC state to this cache line *CHECK*
						  trigger(Event:L1_Replacement, in_msg.LineAddress,
						          L1Icache_entry, TBEs[in_msg.LineAddress]);
						}

						// in neither cache
						if (L1Dcache.cacheAvail(in_msg.LineAddress)) {			//Nirvedh judgement call not sure about =the nested if structures
						  // L1 does't have the line, but we have space for it
						  // in the L1 let's see if the L2 has it.

							//David add
							if(rcc.isPresent_RCC(in_msg.LineAddress)){ //Ravali
							//Match in RCC! This means if we have permission, we can do RCC_GET
								if(mandatory_request_type_to_event(in_msg.Type) == Event:Load || mandatory_request_type_to_event(in_msg.Type) == Event:Ifetch){

									trigger(Event:RCC_HIT, in_msg.LineAddress, L1Dcache_entry, TBEs[in_msg.LineAddress]);
								}
								if(mandatory_request_type_to_event(in_msg.Type) == Event:Store && (isWriteState(DavidgetRCCState(in_msg.LineAddress)))){
								//have RCC hit, asked for write, and we also have permission
									trigger(Event:RCC_HIT, in_msg.LineAddress, L1Dcache_entry, TBEs[in_msg.LineAddress]);					
								} /*CHECK*/
							}
							else{ //no RCC hit -- normal request
						  			trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.LineAddress, L1Dcache_entry, TBEs[in_msg.LineAddress]);
						  	}
						} else {
						  // No room in the L1, so we need to make room in the L1
						  trigger(Event:L1_Replacement, L1Dcache.cacheProbe(in_msg.LineAddress),
						          getL1DCacheEntry(L1Dcache.cacheProbe(in_msg.LineAddress)),
						          TBEs[L1Dcache.cacheProbe(in_msg.LineAddress)]);
						}
		      
					}
      }
      }
    }
  }
  //Nirvedh judgement call there were three more close brackets in base protocol so added those nut i needed 4 to get this going
 

 void DavidissuePUTX(Addr address,Entry cache_entry){
	if(is_valid(cache_entry) && cache_entry.Dirty){ // cache entry is in the block you're losing permission to, and it's now dirty. May the writebacks begin...
	 enqueue(requestL1Network_out, RequestMsg, l1_response_latency) {

	      out_msg.addr := address;
	      out_msg.Type := CoherenceRequestType:PUTX;
	      out_msg.DataBlk := cache_entry.DataBlk;
	      out_msg.Dirty := cache_entry.Dirty;
	      out_msg.Requestor:= machineID;
	      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
		                  l2_select_low_bit, l2_select_num_bits, intToID(0)));
	      if (cache_entry.Dirty) {
		out_msg.MessageSize := MessageSizeType:Writeback_Data;
	      } else {
		out_msg.MessageSize := MessageSizeType:Writeback_Control;
	      }
	    }
	}

}

  void enqueuePrefetch(Addr address, RubyRequestType type) {
      enqueue(optionalQueue_out, RubyRequest, 1) {
          out_msg.LineAddress := address;
          out_msg.Type := type;
          out_msg.AccessMode := RubyAccessMode:Supervisor;
      }
  }

  // ACTIONS
  action(a_issueGETS, "a", desc="Issue GETS") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETS;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        //DPRINTF(RubySlicc, "address: %s, destination: %s\n",
          //      address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(pa_issuePfGETS, "pa", desc="Issue prefetch GETS") {
    peek(optionalQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETS;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        //DPRINTF(RubySlicc, "address: %s, destination: %s\n",
           //     address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(ai_issueGETINSTR, "ai", desc="Issue GETINSTR") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GET_INSTR;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        //DPRINTF(RubySlicc, "address: %s, destination: %s\n",
             //   address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(pai_issuePfGETINSTR, "pai",
         desc="Issue GETINSTR for prefetch request") {
      peek(optionalQueue_in, RubyRequest) {
          enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
              out_msg.addr := address;
              out_msg.Type := CoherenceRequestType:GET_INSTR;
              out_msg.Requestor := machineID;
              out_msg.Destination.add(
                  mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Prefetch := in_msg.Prefetch;
              out_msg.AccessMode := in_msg.AccessMode;

              //DPRINTF(RubySlicc, "address: %s, destination: %s\n",
               //       address, out_msg.Destination);
          }
      }
  }

  action(b_issueGETX, "b", desc="Issue GETX") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETX;
        out_msg.Requestor := machineID;
        //DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        //DPRINTF(RubySlicc, "address: %s, destination: %s\n",
               // address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(pb_issuePfGETX, "pb", desc="Issue prefetch GETX") {
      peek(optionalQueue_in, RubyRequest) {
          enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
              out_msg.addr := address;
              out_msg.Type := CoherenceRequestType:GETX;
              out_msg.Requestor := machineID;
              //DPRINTF(RubySlicc, "%s\n", machineID);

              out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));

              //DPRINTF(RubySlicc, "address: %s, destination: %s\n",
                 //     address, out_msg.Destination);
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Prefetch := in_msg.Prefetch;
              out_msg.AccessMode := in_msg.AccessMode;
          }
      }
//{ //Ravali -- Removed extra brackets
//}
  }

  action(c_issueUPGRADE, "c", desc="Issue GETX") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg,  l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:UPGRADE;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        //DPRINTF(RubySlicc, "address: %s, destination: %s\n",
               // address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }


  action(d_sendDataToRequestor, "d", desc="send data to requestor") {
	if(is_valid(cache_entry)){
		peek(requestL1Network_in, RequestMsg) {
		  enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
		    assert(is_valid(cache_entry)); 
		    out_msg.addr := address;
		    out_msg.Type := CoherenceResponseType:DATA;
		    out_msg.DataBlk := cache_entry.DataBlk;
		    out_msg.Dirty := cache_entry.Dirty;
		    out_msg.Sender := machineID;
		    out_msg.Destination.add(in_msg.Requestor);
		    out_msg.MessageSize := MessageSizeType:Response_Data;
		  }
      	}
    }
  }

  action(d2_sendDataToL2, "d2", desc="send data to the L2 cache because of M downgrade") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      if(is_valid(cache_entry)){ // check if you have data, if so send to L2. May not have data, but L2 forwarded a getX to you anyways
	      out_msg.addr := address;
	      out_msg.Type := CoherenceResponseType:DATA;
	      out_msg.DataBlk := cache_entry.DataBlk;
	      out_msg.Dirty := cache_entry.Dirty;
	      out_msg.Sender := machineID;
	      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
		                  l2_select_low_bit, l2_select_num_bits, intToID(0)));
	      out_msg.MessageSize := MessageSizeType:Response_Data;
	}
    }
  }

  action(dt_sendDataToRequestor_fromTBE, "dt", desc="send data to requestor") {
	if(is_valid(tbe)){
		peek(requestL1Network_in, RequestMsg) {
		  enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
		    assert(is_valid(tbe));
		    out_msg.addr := address;
		    out_msg.Type := CoherenceResponseType:DATA;
		    out_msg.DataBlk := tbe.DataBlk;
		    out_msg.Dirty := tbe.Dirty;
		    out_msg.Sender := machineID;
		    out_msg.Destination.add(in_msg.Requestor);
		    out_msg.MessageSize := MessageSizeType:Response_Data;
		}
      }
    }
  }

  action(d2t_sendDataToL2_fromTBE, "d2t", desc="send data to the L2 cache") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
     if(is_valid(tbe)){ //Send data if you have. L2 may have forwarded GETX  even if you don't have
	      out_msg.addr := address;
	      out_msg.Type := CoherenceResponseType:DATA;
	      out_msg.DataBlk := tbe.DataBlk;
	      out_msg.Dirty := tbe.Dirty;
	      out_msg.Sender := machineID;
	      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
		                  l2_select_low_bit, l2_select_num_bits, intToID(0)));
	      out_msg.MessageSize := MessageSizeType:Response_Data;
	}
    }
  }

  action(e_sendAckToRequestor, "e", desc="send invalidate ack to requestor (could be L2 or L1)") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:ACK;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Control;
      }
    }
  }

  action(f_sendDataToL2, "f", desc="send data to the L2 cache") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      if(is_valid(cache_entry)){
	      out_msg.addr := address;
	      out_msg.Type := CoherenceResponseType:DATA;
	      out_msg.DataBlk := cache_entry.DataBlk;
	      out_msg.Dirty := cache_entry.Dirty;
	      out_msg.Sender := machineID;
	      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
		                  l2_select_low_bit, l2_select_num_bits, intToID(0)));
	      out_msg.MessageSize := MessageSizeType:Writeback_Data;
	}
    }
  }

  action(ft_sendDataToL2_fromTBE, "ft", desc="send data to the L2 cache") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      if(is_valid(tbe)){
	      out_msg.addr := address;
	      out_msg.Type := CoherenceResponseType:DATA;
	      out_msg.DataBlk := tbe.DataBlk;
	      out_msg.Dirty := tbe.Dirty;
	      out_msg.Sender := machineID;
	      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
		                  l2_select_low_bit, l2_select_num_bits, intToID(0)));
	      out_msg.MessageSize := MessageSizeType:Writeback_Data;
	}
    }
  }

  action(fi_sendInvAck, "fi", desc="send data to the L2 cache") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:ACK;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Control;
        out_msg.AckCount := 1;
      }
    }
  }

  action(forward_eviction_to_cpu, "\cc", desc="sends eviction information to the processor") {
    if (send_evictions) {
      //DPRINTF(RubySlicc, "Sending invalidation for %s to the CPU\n", address);
      sequencer.evictionCallback(address);
    }
  }

  action(g_issuePUTX, "g", desc="send data to the L2 cache") {
    enqueue(requestL1Network_out, RequestMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:PUTX;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Requestor:= machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      if (cache_entry.Dirty) {
        out_msg.MessageSize := MessageSizeType:Writeback_Data;
      } else {
        out_msg.MessageSize := MessageSizeType:Writeback_Control;
      }
    }
  }

  action(j_sendUnblock, "j", desc="send unblock to the L2 cache") {
    enqueue(unblockNetwork_out, ResponseMsg, to_l2_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:UNBLOCK;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Response_Control;
      //DPRINTF(RubySlicc, "%s\n", address);
    }
  }

  action(jj_sendExclusiveUnblock, "\j", desc="send unblock to the L2 cache") {
    enqueue(unblockNetwork_out, ResponseMsg, to_l2_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:EXCLUSIVE_UNBLOCK;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Response_Control;
      //DPRINTF(RubySlicc, "%s\n", address);

    }
  }

  action(dg_invalidate_sc, "dg",
         desc="Invalidate store conditional as the cache lost permissions") {
    sequencer.invalidateSC(address);
  }

  action(h_load_hit, "h",
         desc="If not prefetch, notify sequencer the load completed.")
  {
    assert(is_valid(cache_entry));
    //DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    sequencer.readCallback(address, cache_entry.DataBlk);
  }

  action(hx_load_hit, "hx",
         desc="If not prefetch, notify sequencer the load completed.")
  {
    assert(is_valid(cache_entry));
    //DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    sequencer.readCallback(address, cache_entry.DataBlk, true);
  }

  action(hh_store_hit, "\h",
         desc="If not prefetch, notify sequencer that store completed.")
  {
    assert(is_valid(cache_entry));
    //DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    sequencer.writeCallback(address, cache_entry.DataBlk);
    cache_entry.Dirty := true;
  }

  action(hhx_store_hit, "\hx",
         desc="If not prefetch, notify sequencer that store completed.")
  {
    assert(is_valid(cache_entry));
    //DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    sequencer.writeCallback(address, cache_entry.DataBlk, true);
    cache_entry.Dirty := true;
  }

  action(i_allocateTBE, "i", desc="Allocate TBE (isPrefetch=0, number of invalidates=0)") {
    check_allocate(TBEs);
    assert(is_valid(cache_entry));
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
    tbe.isPrefetch := false;
    tbe.Dirty := cache_entry.Dirty;
    tbe.DataBlk := cache_entry.DataBlk;
  }

  action(k_popMandatoryQueue, "k", desc="Pop mandatory queue.") {
    mandatoryQueue_in.dequeue(clockEdge());
    DPRINTF(RubySlicc, "successfully popped queue this was not reaching\n"); //Nirvedh Track fix me  
  }

  action(l_popRequestQueue, "l",
    desc="Pop incoming request queue and profile the delay within this virtual network") {
    profileMsgDelay(2, ticksToCycles(requestL1Network_in.dequeue(clockEdge()))); //Ravali -- missing ticksToCycles
  }

  action(o_popIncomingResponseQueue, "o",
    desc="Pop Incoming Response queue and profile the delay within this virtual network") {
    profileMsgDelay(1, ticksToCycles(responseL1Network_in.dequeue(clockEdge()))); //Ravali -- missing ticksToCycles
  }

  action(s_deallocateTBE, "s", desc="Deallocate TBE") {
    TBEs.deallocate(address);
    unset_tbe();
  }

  action(u_writeDataToL1Cache, "u", desc="Write data to cache") {
    peek(responseL1Network_in, ResponseMsg) {
      assert(is_valid(cache_entry));
      cache_entry.DataBlk := in_msg.DataBlk;
      cache_entry.Dirty := in_msg.Dirty;
    }
  }

  action(q_updateAckCount, "q", desc="Update ack count") {
    peek(responseL1Network_in, ResponseMsg) {
      assert(is_valid(tbe));
      tbe.pendingAcks := tbe.pendingAcks - in_msg.AckCount;
      APPEND_TRANSITION_COMMENT(in_msg.AckCount);
      APPEND_TRANSITION_COMMENT(" p: ");
      APPEND_TRANSITION_COMMENT(tbe.pendingAcks);
    }
  }

  action(ff_deallocateL1CacheBlock, "\f", desc="Deallocate L1 cache block.  Sets the cache to not present, allowing a replacement in parallel with a fetch.") {
    if (L1Dcache.isTagPresent(address)) {
      L1Dcache.deallocate(address);
    } else {
      L1Icache.deallocate(address);
    }
    unset_cache_entry();
  }

  action(oo_allocateL1DCacheBlock, "\o", desc="Set L1 D-cache tag equal to tag of block B.") {
    if (is_invalid(cache_entry)) {
      set_cache_entry(L1Dcache.allocate(address, new Entry));
    }
  }

  action(pp_allocateL1ICacheBlock, "\p", desc="Set L1 I-cache tag equal to tag of block B.") {
    if (is_invalid(cache_entry)) {
    DPRINTF(RubySlicc, "it does have invalid cache entry\n"); //Nirvedh Track 2
      set_cache_entry(L1Icache.allocate(address, new Entry));
    }
  }

  action(z_stallAndWaitMandatoryQueue, "\z", desc="recycle L1 request queue") {
    stall_and_wait(mandatoryQueue_in, address);
    
  }

  action(kd_wakeUpDependents, "kd", desc="wake-up dependents") {
	DPRINTF(RubySlicc, "about to wake up dependent");
    wakeUpBuffers(address);
	DPRINTF(RubySlicc, "woke up dependent");
  }

  action(uu_profileInstMiss, "\uim", desc="Profile the demand miss") {
      ++L1Icache.demand_misses;
  }

  action(uu_profileInstHit, "\uih", desc="Profile the demand hit") {
      ++L1Icache.demand_hits;
  }

  action(uu_profileDataMiss, "\udm", desc="Profile the demand miss") {
      ++L1Dcache.demand_misses;
  }

  action(uu_profileDataHit, "\udh", desc="Profile the demand hit") {
      ++L1Dcache.demand_hits;
  }

  action(po_observeMiss, "\po", desc="Inform the prefetcher about the miss") {
      peek(mandatoryQueue_in, RubyRequest) {
          if (enable_prefetch) {
              prefetcher.observeMiss(in_msg.LineAddress, in_msg.Type);
          }
      }
  }

  action(ppm_observePfMiss, "\ppm",
         desc="Inform the prefetcher about the partial miss") {
      peek(mandatoryQueue_in, RubyRequest) {
          prefetcher.observePfMiss(in_msg.LineAddress);
      }
  }

  action(pq_popPrefetchQueue, "\pq", desc="Pop the prefetch request queue") {
      optionalQueue_in.dequeue(clockEdge());
  }

  action(mp_markPrefetched, "mp", desc="Write data from response queue to cache") {
      assert(is_valid(cache_entry));
      cache_entry.isPrefetch := true;
  }


//David TODO -- insert new actions / functions from RCC C++ file
  action(a_splitRCC, "sRCC", desc="split the RCC if possible. If lowest granularity, send signal to invalidate.") {
	peek(responseL1Network_in, ResponseMsg) {
      	assert(is_valid(cache_entry));
	assert(rcc.isPresent_RCC(address));
		rcc.split(in_msg.addr);
	}
  }

  action(a_issueRCC_GET, "RCCg", desc="Issue RCC_GET") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:RCC_GET; //may need to change the request type
        out_msg.Requestor := machineID;
        //DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        //DPRINTF(RubySlicc, "address: %s, destination: %s\n",
                //address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(a_sendRCC_allocateToRequestor, "RCC_al_fromL1", desc="send RCC allocate to requestor") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:RCC_ALLOCATE; //Ravali - RCC_allocate to RCC_ALLOCATE CoherenceResponseType: RCC_ALLOCATE, event: RCC_allocate
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.Dirty := cache_entry.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }
  }

  action(a_sendAckNack, "anRCC", desc="send ack/nack to requestor (do or do not have data)") { 
	peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        out_msg.addr := address;
        if(is_valid(cache_entry)) {
			out_msg.Type := CoherenceResponseType:ACK; 
		}
		else{
			out_msg.Type := CoherenceResponseType:NACK_RCC; //Ravali
		}
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Control;
      }
    }
  }

  action(at_sendAckNack, "t_anRCC", desc="send ack/nack to requestor (do or do not have data) FROM TBE") { 
	peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        out_msg.addr := address;
        if(is_valid(tbe)) {
			out_msg.Type := CoherenceResponseType:ACK; 
		}
		else{
			out_msg.Type := CoherenceResponseType:NACK_RCC; //Ravali
		}
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Control;
      }
    }
  }

  action(a_allocateRCC, "aRCC", desc = "use info from message to allocate RCC entry") {
  DPRINTF(RubySlicc, "allocate before peeking in the network\n");
	peek(responseL1Network_in, ResponseMsg) {
       DPRINTF(RubySlicc, "before the assert in the peek\n");
      assert(is_valid(cache_entry));
      DPRINTF(RubySlicc, "successfully reached point before allocate\n"); //Nirvedh track 4
	if(!rcc.isPresent_RCC(address)){      
		rcc.allocate(in_msg.mask,in_msg.granularity); /*CHECK*/
     		 DPRINTF(RubySlicc, "successfully reached point after L1 RCC allocate\n");
	}
	assert(rcc.isPresent_RCC(address));
    }
    DPRINTF(RubySlicc, "rcc allocate end of action\n");

  }
  
  

  action(a_multiplePUTX, "mPUTX", desc = "write back all modified data to the L2") {
	//David TODO
	assert(rcc.isPresent_RCC(address));
	int gran := rcc.getGranularity(address);
	Addr mask := rcc.getMask(address);

	//stupid SM files don't support loops. I apologize for the hacky code. Sorry Professor Hill  ='( 
	if(gran==64){
		DavidissuePUTX(mask,getCacheEntry(mask));
		DavidissuePUTX(makeNextStrideAddress(mask,1),getCacheEntry(makeNextStrideAddress(mask,1)));
		DavidissuePUTX(makeNextStrideAddress(mask,2),getCacheEntry(makeNextStrideAddress(mask,2)));
		DavidissuePUTX(makeNextStrideAddress(mask,3),getCacheEntry(makeNextStrideAddress(mask,3)));
		DavidissuePUTX(makeNextStrideAddress(mask,4),getCacheEntry(makeNextStrideAddress(mask,4)));
		DavidissuePUTX(makeNextStrideAddress(mask,5),getCacheEntry(makeNextStrideAddress(mask,5)));
		DavidissuePUTX(makeNextStrideAddress(mask,6),getCacheEntry(makeNextStrideAddress(mask,6)));
		DavidissuePUTX(makeNextStrideAddress(mask,7),getCacheEntry(makeNextStrideAddress(mask,7)));
		DavidissuePUTX(makeNextStrideAddress(mask,8),getCacheEntry(makeNextStrideAddress(mask,8)));
		DavidissuePUTX(makeNextStrideAddress(mask,9),getCacheEntry(makeNextStrideAddress(mask,9)));
		DavidissuePUTX(makeNextStrideAddress(mask,10),getCacheEntry(makeNextStrideAddress(mask,10)));
		DavidissuePUTX(makeNextStrideAddress(mask,11),getCacheEntry(makeNextStrideAddress(mask,11)));
		DavidissuePUTX(makeNextStrideAddress(mask,12),getCacheEntry(makeNextStrideAddress(mask,12)));
		DavidissuePUTX(makeNextStrideAddress(mask,13),getCacheEntry(makeNextStrideAddress(mask,13)));
		DavidissuePUTX(makeNextStrideAddress(mask,14),getCacheEntry(makeNextStrideAddress(mask,14)));
		DavidissuePUTX(makeNextStrideAddress(mask,15),getCacheEntry(makeNextStrideAddress(mask,15)));
		DavidissuePUTX(makeNextStrideAddress(mask,16),getCacheEntry(makeNextStrideAddress(mask,16)));
		DavidissuePUTX(makeNextStrideAddress(mask,17),getCacheEntry(makeNextStrideAddress(mask,17)));
		DavidissuePUTX(makeNextStrideAddress(mask,18),getCacheEntry(makeNextStrideAddress(mask,18)));
		DavidissuePUTX(makeNextStrideAddress(mask,19),getCacheEntry(makeNextStrideAddress(mask,19)));
		DavidissuePUTX(makeNextStrideAddress(mask,20),getCacheEntry(makeNextStrideAddress(mask,20)));
		DavidissuePUTX(makeNextStrideAddress(mask,21),getCacheEntry(makeNextStrideAddress(mask,21)));
		DavidissuePUTX(makeNextStrideAddress(mask,22),getCacheEntry(makeNextStrideAddress(mask,22)));
		DavidissuePUTX(makeNextStrideAddress(mask,23),getCacheEntry(makeNextStrideAddress(mask,23)));
		DavidissuePUTX(makeNextStrideAddress(mask,24),getCacheEntry(makeNextStrideAddress(mask,24)));
		DavidissuePUTX(makeNextStrideAddress(mask,25),getCacheEntry(makeNextStrideAddress(mask,25)));
		DavidissuePUTX(makeNextStrideAddress(mask,26),getCacheEntry(makeNextStrideAddress(mask,26)));
		DavidissuePUTX(makeNextStrideAddress(mask,27),getCacheEntry(makeNextStrideAddress(mask,27)));
		DavidissuePUTX(makeNextStrideAddress(mask,28),getCacheEntry(makeNextStrideAddress(mask,28)));
		DavidissuePUTX(makeNextStrideAddress(mask,29),getCacheEntry(makeNextStrideAddress(mask,29)));
		DavidissuePUTX(makeNextStrideAddress(mask,30),getCacheEntry(makeNextStrideAddress(mask,30)));
		DavidissuePUTX(makeNextStrideAddress(mask,31),getCacheEntry(makeNextStrideAddress(mask,31)));
		DavidissuePUTX(makeNextStrideAddress(mask,32),getCacheEntry(makeNextStrideAddress(mask,32)));
		DavidissuePUTX(makeNextStrideAddress(mask,33),getCacheEntry(makeNextStrideAddress(mask,33)));
		DavidissuePUTX(makeNextStrideAddress(mask,34),getCacheEntry(makeNextStrideAddress(mask,34)));
		DavidissuePUTX(makeNextStrideAddress(mask,35),getCacheEntry(makeNextStrideAddress(mask,35)));
		DavidissuePUTX(makeNextStrideAddress(mask,36),getCacheEntry(makeNextStrideAddress(mask,36)));
		DavidissuePUTX(makeNextStrideAddress(mask,37),getCacheEntry(makeNextStrideAddress(mask,37)));
		DavidissuePUTX(makeNextStrideAddress(mask,38),getCacheEntry(makeNextStrideAddress(mask,38)));
		DavidissuePUTX(makeNextStrideAddress(mask,39),getCacheEntry(makeNextStrideAddress(mask,39)));
		DavidissuePUTX(makeNextStrideAddress(mask,40),getCacheEntry(makeNextStrideAddress(mask,40)));
		DavidissuePUTX(makeNextStrideAddress(mask,41),getCacheEntry(makeNextStrideAddress(mask,41)));
		DavidissuePUTX(makeNextStrideAddress(mask,42),getCacheEntry(makeNextStrideAddress(mask,42)));
		DavidissuePUTX(makeNextStrideAddress(mask,43),getCacheEntry(makeNextStrideAddress(mask,43)));
		DavidissuePUTX(makeNextStrideAddress(mask,44),getCacheEntry(makeNextStrideAddress(mask,44)));
		DavidissuePUTX(makeNextStrideAddress(mask,45),getCacheEntry(makeNextStrideAddress(mask,45)));
		DavidissuePUTX(makeNextStrideAddress(mask,46),getCacheEntry(makeNextStrideAddress(mask,46)));
		DavidissuePUTX(makeNextStrideAddress(mask,47),getCacheEntry(makeNextStrideAddress(mask,47)));
		DavidissuePUTX(makeNextStrideAddress(mask,48),getCacheEntry(makeNextStrideAddress(mask,48)));
		DavidissuePUTX(makeNextStrideAddress(mask,49),getCacheEntry(makeNextStrideAddress(mask,49)));
		DavidissuePUTX(makeNextStrideAddress(mask,50),getCacheEntry(makeNextStrideAddress(mask,50)));
		DavidissuePUTX(makeNextStrideAddress(mask,51),getCacheEntry(makeNextStrideAddress(mask,51)));
		DavidissuePUTX(makeNextStrideAddress(mask,52),getCacheEntry(makeNextStrideAddress(mask,52)));
		DavidissuePUTX(makeNextStrideAddress(mask,53),getCacheEntry(makeNextStrideAddress(mask,53)));
		DavidissuePUTX(makeNextStrideAddress(mask,54),getCacheEntry(makeNextStrideAddress(mask,54)));
		DavidissuePUTX(makeNextStrideAddress(mask,55),getCacheEntry(makeNextStrideAddress(mask,55)));
		DavidissuePUTX(makeNextStrideAddress(mask,56),getCacheEntry(makeNextStrideAddress(mask,56)));
		DavidissuePUTX(makeNextStrideAddress(mask,57),getCacheEntry(makeNextStrideAddress(mask,57)));
		DavidissuePUTX(makeNextStrideAddress(mask,58),getCacheEntry(makeNextStrideAddress(mask,58)));
		DavidissuePUTX(makeNextStrideAddress(mask,59),getCacheEntry(makeNextStrideAddress(mask,59)));
		DavidissuePUTX(makeNextStrideAddress(mask,60),getCacheEntry(makeNextStrideAddress(mask,60)));
		DavidissuePUTX(makeNextStrideAddress(mask,61),getCacheEntry(makeNextStrideAddress(mask,61)));
		DavidissuePUTX(makeNextStrideAddress(mask,62),getCacheEntry(makeNextStrideAddress(mask,62)));
		DavidissuePUTX(makeNextStrideAddress(mask,63),getCacheEntry(makeNextStrideAddress(mask,63)));

	}

	if(gran==32){
		DavidissuePUTX(mask,getCacheEntry(mask));
		DavidissuePUTX(makeNextStrideAddress(mask,1),getCacheEntry(makeNextStrideAddress(mask,1)));
		DavidissuePUTX(makeNextStrideAddress(mask,2),getCacheEntry(makeNextStrideAddress(mask,2)));
		DavidissuePUTX(makeNextStrideAddress(mask,3),getCacheEntry(makeNextStrideAddress(mask,3)));
		DavidissuePUTX(makeNextStrideAddress(mask,4),getCacheEntry(makeNextStrideAddress(mask,4)));
		DavidissuePUTX(makeNextStrideAddress(mask,5),getCacheEntry(makeNextStrideAddress(mask,5)));
		DavidissuePUTX(makeNextStrideAddress(mask,6),getCacheEntry(makeNextStrideAddress(mask,6)));
		DavidissuePUTX(makeNextStrideAddress(mask,7),getCacheEntry(makeNextStrideAddress(mask,7)));
		DavidissuePUTX(makeNextStrideAddress(mask,8),getCacheEntry(makeNextStrideAddress(mask,8)));
		DavidissuePUTX(makeNextStrideAddress(mask,9),getCacheEntry(makeNextStrideAddress(mask,9)));
		DavidissuePUTX(makeNextStrideAddress(mask,10),getCacheEntry(makeNextStrideAddress(mask,10)));
		DavidissuePUTX(makeNextStrideAddress(mask,11),getCacheEntry(makeNextStrideAddress(mask,11)));
		DavidissuePUTX(makeNextStrideAddress(mask,12),getCacheEntry(makeNextStrideAddress(mask,12)));
		DavidissuePUTX(makeNextStrideAddress(mask,13),getCacheEntry(makeNextStrideAddress(mask,13)));
		DavidissuePUTX(makeNextStrideAddress(mask,14),getCacheEntry(makeNextStrideAddress(mask,14)));
		DavidissuePUTX(makeNextStrideAddress(mask,15),getCacheEntry(makeNextStrideAddress(mask,15)));
		DavidissuePUTX(makeNextStrideAddress(mask,16),getCacheEntry(makeNextStrideAddress(mask,16)));
		DavidissuePUTX(makeNextStrideAddress(mask,17),getCacheEntry(makeNextStrideAddress(mask,17)));
		DavidissuePUTX(makeNextStrideAddress(mask,18),getCacheEntry(makeNextStrideAddress(mask,18)));
		DavidissuePUTX(makeNextStrideAddress(mask,19),getCacheEntry(makeNextStrideAddress(mask,19)));
		DavidissuePUTX(makeNextStrideAddress(mask,20),getCacheEntry(makeNextStrideAddress(mask,20)));
		DavidissuePUTX(makeNextStrideAddress(mask,21),getCacheEntry(makeNextStrideAddress(mask,21)));
		DavidissuePUTX(makeNextStrideAddress(mask,22),getCacheEntry(makeNextStrideAddress(mask,22)));
		DavidissuePUTX(makeNextStrideAddress(mask,23),getCacheEntry(makeNextStrideAddress(mask,23)));
		DavidissuePUTX(makeNextStrideAddress(mask,24),getCacheEntry(makeNextStrideAddress(mask,24)));
		DavidissuePUTX(makeNextStrideAddress(mask,25),getCacheEntry(makeNextStrideAddress(mask,25)));
		DavidissuePUTX(makeNextStrideAddress(mask,26),getCacheEntry(makeNextStrideAddress(mask,26)));
		DavidissuePUTX(makeNextStrideAddress(mask,27),getCacheEntry(makeNextStrideAddress(mask,27)));
		DavidissuePUTX(makeNextStrideAddress(mask,28),getCacheEntry(makeNextStrideAddress(mask,28)));
		DavidissuePUTX(makeNextStrideAddress(mask,29),getCacheEntry(makeNextStrideAddress(mask,29)));
		DavidissuePUTX(makeNextStrideAddress(mask,30),getCacheEntry(makeNextStrideAddress(mask,30)));
		DavidissuePUTX(makeNextStrideAddress(mask,31),getCacheEntry(makeNextStrideAddress(mask,31)));

	}
	if(gran==16){
		DavidissuePUTX(mask,getCacheEntry(mask));
		DavidissuePUTX(makeNextStrideAddress(mask,1),getCacheEntry(makeNextStrideAddress(mask,1)));
		DavidissuePUTX(makeNextStrideAddress(mask,2),getCacheEntry(makeNextStrideAddress(mask,2)));
		DavidissuePUTX(makeNextStrideAddress(mask,3),getCacheEntry(makeNextStrideAddress(mask,3)));
		DavidissuePUTX(makeNextStrideAddress(mask,4),getCacheEntry(makeNextStrideAddress(mask,4)));
		DavidissuePUTX(makeNextStrideAddress(mask,5),getCacheEntry(makeNextStrideAddress(mask,5)));
		DavidissuePUTX(makeNextStrideAddress(mask,6),getCacheEntry(makeNextStrideAddress(mask,6)));
		DavidissuePUTX(makeNextStrideAddress(mask,7),getCacheEntry(makeNextStrideAddress(mask,7)));
		DavidissuePUTX(makeNextStrideAddress(mask,8),getCacheEntry(makeNextStrideAddress(mask,8)));
		DavidissuePUTX(makeNextStrideAddress(mask,9),getCacheEntry(makeNextStrideAddress(mask,9)));
		DavidissuePUTX(makeNextStrideAddress(mask,10),getCacheEntry(makeNextStrideAddress(mask,10)));
		DavidissuePUTX(makeNextStrideAddress(mask,11),getCacheEntry(makeNextStrideAddress(mask,11)));
		DavidissuePUTX(makeNextStrideAddress(mask,12),getCacheEntry(makeNextStrideAddress(mask,12)));
		DavidissuePUTX(makeNextStrideAddress(mask,13),getCacheEntry(makeNextStrideAddress(mask,13)));
		DavidissuePUTX(makeNextStrideAddress(mask,14),getCacheEntry(makeNextStrideAddress(mask,14)));
		DavidissuePUTX(makeNextStrideAddress(mask,15),getCacheEntry(makeNextStrideAddress(mask,15)));
	}

	if(gran==8){
		DavidissuePUTX(mask,getCacheEntry(mask));
		DavidissuePUTX(makeNextStrideAddress(mask,1),getCacheEntry(makeNextStrideAddress(mask,1)));
		DavidissuePUTX(makeNextStrideAddress(mask,2),getCacheEntry(makeNextStrideAddress(mask,2)));
		DavidissuePUTX(makeNextStrideAddress(mask,3),getCacheEntry(makeNextStrideAddress(mask,3)));
		DavidissuePUTX(makeNextStrideAddress(mask,4),getCacheEntry(makeNextStrideAddress(mask,4)));
		DavidissuePUTX(makeNextStrideAddress(mask,5),getCacheEntry(makeNextStrideAddress(mask,5)));
		DavidissuePUTX(makeNextStrideAddress(mask,6),getCacheEntry(makeNextStrideAddress(mask,6)));
		DavidissuePUTX(makeNextStrideAddress(mask,7),getCacheEntry(makeNextStrideAddress(mask,7)));
	}

	if(gran==4){
		DavidissuePUTX(mask,getCacheEntry(mask));
		DavidissuePUTX(makeNextStrideAddress(mask,1),getCacheEntry(makeNextStrideAddress(mask,1)));
		DavidissuePUTX(makeNextStrideAddress(mask,2),getCacheEntry(makeNextStrideAddress(mask,2)));
		DavidissuePUTX(makeNextStrideAddress(mask,3),getCacheEntry(makeNextStrideAddress(mask,3)));
	}

	if(gran==2){
		DavidissuePUTX(mask,getCacheEntry(mask));
		DavidissuePUTX(makeNextStrideAddress(mask,1),getCacheEntry(makeNextStrideAddress(mask,1)));
	}

	else{
		DavidissuePUTX(mask,getCacheEntry(mask));
	}


}

/* *CHECK* Type 'RCTable' does not have a method setRCCL1State, 'setRCCL1State_Addr_L1Cache_State' nor '':*/

  action(setStateNP,"ssnp", desc="set RCC to NP"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:NP));
  }

  action(setStateI,"ssi", desc="set RCC to I"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:I));
  }

  action(setStateS,"sss", desc="set RCC to S"){
	DPRINTF(RubySlicc, "about to set state S");
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:S));
	DPRINTF(RubySlicc, "done with setRCC to S");
  }

  action(setStateE,"sse", desc="set RCC to E"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:E));
  }

  action(setStateM,"ssm", desc="set RCC to M"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:M));
  }

  action(setStateIS,"ssIS", desc="set RCC to IS"){
  assert(rcc.isPresent_RCC(address)); 
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:IS));
  }

  action(setStateIM,"ssIM", desc="set RCC to IM"){
	assert(rcc.isPresent_RCC(address)); 
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:IM));
  }

  action(setStateSM,"ssSM", desc="set RCC to SM"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:SM));
  }

  action(setStateIS_I,"ssISI", desc="set RCC to IS_I"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:IS_I));
  }

  action(setStateSINK,"ssSINK", desc="set RCC to SINK_WB_ACK"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:SINK_WB_ACK));
  }

  action(setStatePF_IS,"ssPF_IS", desc="set RCC to PF_IS"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:PF_IS));
  }

  action(setStatePF_IM,"ssPF_IM", desc="set RCC to PF_IM"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:PF_IM));
  }

  action(setStatePF_SM,"ssPF_SM", desc="set RCC to PF_SM"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:PF_SM));
  }

  action(setStatePF_IS_I,"ssPF_IS_I", desc="set RCC to PF_IS_I"){
	assert(rcc.isPresent_RCC(address));
	rcc.setRCCL1State(address,L1Cache_State_to_string(State:PF_IS_I));
  }



  //*****************************************************
  // TRANSITIONS
  //*****************************************************

  // Transitions for Load/Store/Replacement/WriteBack from transient states
  transition({IS, IM, IS_I, M_I, SM, SINK_WB_ACK}, {Load, Ifetch, Store, L1_Replacement}) {
    z_stallAndWaitMandatoryQueue;
  }

  transition({PF_IS, PF_IS_I}, {Store, L1_Replacement}) {
    z_stallAndWaitMandatoryQueue;
  }

  transition({PF_IM, PF_SM}, {Load, Ifetch, L1_Replacement}) {
    z_stallAndWaitMandatoryQueue;
  }

  // Transitions from Idle
  transition({NP,I}, L1_Replacement) {
    ff_deallocateL1CacheBlock;
  }

  transition({S,E,M,IS,IM,SM,IS_I,M_I,SINK_WB_ACK,PF_IS,PF_IM},
             {PF_Load, PF_Store, PF_Ifetch}) {
      pq_popPrefetchQueue;
  }

  transition({NP,I}, Load, IS) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    a_issueGETS;
    uu_profileDataMiss;
    po_observeMiss;
    k_popMandatoryQueue;

  }

  transition({NP,I}, PF_Load, PF_IS) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    pa_issuePfGETS;
    pq_popPrefetchQueue;
  }

  transition(PF_IS, Load, IS) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  transition(PF_IS_I, Load, IS_I) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  transition({NP,I}, Ifetch, IS) { //Nirvedh Track 1
    pp_allocateL1ICacheBlock;
    i_allocateTBE;
    ai_issueGETINSTR;
    uu_profileInstMiss;
    po_observeMiss;
    k_popMandatoryQueue;

  }

  transition({NP,I}, PF_Ifetch, PF_IS) {
    pp_allocateL1ICacheBlock;
    i_allocateTBE;
    pai_issuePfGETINSTR;
    pq_popPrefetchQueue;
  }

  // We proactively assume that the prefetch is in to
  // the instruction cache
  transition(PF_IS, Ifetch, IS) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  transition({NP,I}, Store, IM) {
    oo_allocateL1DCacheBlock;

//David add
	// a_allocateRCC;  // Nirvedh rm

    i_allocateTBE;
    b_issueGETX;
    uu_profileDataMiss;
    po_observeMiss;
    k_popMandatoryQueue;
   //	setStateIM;  //Nirvedh rm
  }

  transition({NP,I}, PF_Store, PF_IM) {
    oo_allocateL1DCacheBlock;

//David add
	//a_allocateRCC;

    i_allocateTBE;
    pb_issuePfGETX;
    pq_popPrefetchQueue;
	//setStatePF_IM;
  }

  transition(PF_IM, Store, IM) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
	//setStateIM;
  }

  transition(PF_SM, Store, SM) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
	//setStateSM;
  }

  transition({NP, I}, Inv) {
    fi_sendInvAck;
    l_popRequestQueue;
  }

  // Transitions from Shared
  transition({S,E,M}, Load) {
    h_load_hit;
    uu_profileDataHit;
    k_popMandatoryQueue;
  }

  transition({S,E,M}, Ifetch) {
    h_load_hit;
    uu_profileInstHit;
    k_popMandatoryQueue;
  }

  transition(S, Store, SM) {
    i_allocateTBE;
    c_issueUPGRADE;
    uu_profileDataMiss;
    k_popMandatoryQueue;
	//setStateSM; // David May1 -- Do not set state, Cache line will reflect so it knows what to do upon response, but the actual block doesn't need
  }

//David-Question: Can we keep in S? If evict and another block asks, the L2 RCC will ask for data (since unknown anyways), and could just send NACK if don't have data
//Believed answer: change cache line to I (no longer in cache), but do not setState to I, keep at current value
  transition(S, L1_Replacement, I) {
    forward_eviction_to_cpu;
    ff_deallocateL1CacheBlock;
  }

//David-Question: Same question -- can we keep in S? Don't want to invalidate entire block if don't have to
//Believed answer: change cache line to I (no longer in cache), but do not setState to I, keep at current value
  transition(S, Inv, I) {
    forward_eviction_to_cpu;
    fi_sendInvAck;
//David add
a_splitRCC;
    l_popRequestQueue;

	
  }

  // Transitions from Exclusive

  transition({E,M}, Store, M) { //silent upgrade
    hh_store_hit;
    uu_profileDataHit;
    k_popMandatoryQueue;
	setStateM;
  }

  transition(E, L1_Replacement, M_I) {
    // silent E replacement??
    forward_eviction_to_cpu;
    i_allocateTBE;
    g_issuePUTX;   // send data, but hold in case forwarded request
    ff_deallocateL1CacheBlock;
	//setStateM_I; //-- do not set state on INV or L1_Replacement
  }

  transition(E, Inv, I) {
    // don't send data
    forward_eviction_to_cpu;

//David add
	a_splitRCC;
    fi_sendInvAck;


    l_popRequestQueue;

  }

//David modify
  transition(E, Fwd_GETX, I) {
    forward_eviction_to_cpu;
    //d_sendDataToRequestor;

//David add
	d2_sendDataToL2; //David May1 -- I think we need, L2 awaiting response?
	//a_multiplePUTX; //David May1 -- do not need, whole block was in E, nothing was dirtied, just split
	a_splitRCC;

    l_popRequestQueue;


	//a_sendAckNack;
	//a_sendRCC_allocateToRequestor;

  }

//David modify
  transition(E, {Fwd_GETS, Fwd_GET_INSTR}, S) {
    //d_sendDataToRequestor;
	// no DavidPutX needed -- whole block was in E, nothing was dirtied
    //a_multiplePUTX;
	setStateS;
    l_popRequestQueue;

//David add
	//a_sendAckNack;

  }

  // Transitions from Modified

  transition(M, L1_Replacement, M_I) {
    forward_eviction_to_cpu;
    i_allocateTBE;
    g_issuePUTX;   // send data, but hold in case forwarded request
    ff_deallocateL1CacheBlock;
	//setStateM_I; //-- do not set state on INV or L1_Replacement
  }

  transition(M_I, WB_Ack, I) {
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	setStateI;
  }

  transition(M, Inv, M_I) {
    forward_eviction_to_cpu;
    f_sendDataToL2;  //David May1 -- not sure -- may need to keep as L2 probably is awaiting response, even though we're about to PUTX everything
   
//David add
	a_multiplePUTX; //David May1 -- before the split, write everything back that you're losing permission to
	a_splitRCC;
 l_popRequestQueue;


  }

  transition(M_I, Inv, SINK_WB_ACK) {
    ft_sendDataToL2_fromTBE;
    l_popRequestQueue;
	setStateSINK;
  }

//David-modified
  transition(M, Fwd_GETX, I) {
    forward_eviction_to_cpu;
    //d_sendDataToRequestor;
    d2_sendDataToL2; //David May1 -- I think we need -- L2 awaits response, even though we will PUTX

//David add
	////a_sendAckNack;
	a_multiplePUTX;
	a_splitRCC;
	//a_sendRCC_allocateToRequestor;

    l_popRequestQueue;


  }

//David modified
  transition(M, {Fwd_GETS, Fwd_GET_INSTR}, S) {
    //d_sendDataToRequestor;
    d2_sendDataToL2; //David May1 -- I think we need -- L2 awaits response, even though we will PUTX

//David add
	////a_sendAckNack;
	a_multiplePUTX; //David May1 -- write back all dirty data so L2 is correct in Shared
	setStateS;

    l_popRequestQueue;


  }

//David modify
  transition(M_I, Fwd_GETX, SINK_WB_ACK) {
    dt_sendDataToRequestor_fromTBE;

//David add
	////a_sendAckNack;
	setStateSINK;

    l_popRequestQueue;

  }

//David modified
  transition(M_I, {Fwd_GETS, Fwd_GET_INSTR}, SINK_WB_ACK) {
    dt_sendDataToRequestor_fromTBE;
    d2t_sendDataToL2_fromTBE;
    l_popRequestQueue;

//David add
	////a_sendAckNack;
	//setStateSINK; //David May1 -- I don't think that entire blocks should ever 
  }

  // Transitions from IS -- no longer want to remove if in IS, can still go to S later. Should split this into two transitions
 // transition({IS, IS_I}, Inv, IS_I) {
 //   fi_sendInvAck;
 //   l_popRequestQueue;
 // }

//David add transition
  transition(IS, Inv, IS_I) {
	fi_sendInvAck;

//David add
	a_splitRCC;

	l_popRequestQueue;


  }

  transition(IS_I, Inv, IS_I) {
	fi_sendInvAck;
	l_popRequestQueue;
  }



//end David add transitions

  transition({PF_IS, PF_IS_I}, Inv, PF_IS_I) {
    fi_sendInvAck;
    l_popRequestQueue;
  }



//David modified
/*CHECK* - Duplicate transition: IS|Data_all_Acks */
  transition(IS, Data_all_Acks, S) {
    u_writeDataToL1Cache;  //Nirvedh track 5
    hx_load_hit;
    s_deallocateTBE;

	//added
	//a_allocateRCC;
	setStateS;

    o_popIncomingResponseQueue;
    kd_wakeUpDependents;


  }


/*CHECK* - Duplicate transition: IS|Data_all_Acks */
  transition(IS, RCC_allocate, S) {  //David Question TODO: Should I keep in IS until all acks are recieved? I think yes...
    u_writeDataToL1Cache; //David May1 -- have IS, Data_All_Acks do these steps
	hx_load_hit;
	s_deallocateTBE; //David May1 
	 
  

	a_allocateRCC;
    o_popIncomingResponseQueue;

	setStateS;
  kd_wakeUpDependents;
  }

//David modified
/*CHECK* - Duplicate transition: [PF_IS|Data_all_Acks */
  transition(PF_IS, Data_all_Acks, S) {
    u_writeDataToL1Cache;
    s_deallocateTBE;
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	setStateS;

  }

/*CHECK* - Duplicate transition: [PF_IS|Data_all_Acks */
  transition(PF_IS, RCC_allocate, PF_IS) {
	//David add
    u_writeDataToL1Cache;
    s_deallocateTBE;
    mp_markPrefetched;
	a_allocateRCC; //Nirvedh Mdfy
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	setStatePF_IS;
  }

/*CHECK* - Duplicate transition: [IS_I|Data_all_Acks */
  transition(IS_I, Data_all_Acks, I) {
    u_writeDataToL1Cache;
    j_sendUnblock;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	setStateI;
  }

/*CHECK* - Duplicate transition: [IS_I|Data_all_Acks */
    transition(IS_I, RCC_allocate, IS_I) {   //May1
    u_writeDataToL1Cache;
    j_sendUnblock;
    hx_load_hit;
    s_deallocateTBE;
	a_allocateRCC;	//David Question May1 -- do not allocate RCC if going to I anyways? Comment this out? 
	setStateIS_I;

    o_popIncomingResponseQueue;
    kd_wakeUpDependents;

  }


/*CHECK* - Duplicate transition: [PF_IS_I|Data_all_Acks */
  transition(PF_IS_I, Data_all_Acks, I) {
    j_sendUnblock;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	setStateI;
  }

  /*CHECK* - Duplicate transition: [PF_IS_I|Data_all_Acks */
  transition(PF_IS_I, RCC_allocate, PF_IS_I) {
  //transition(PF_IS_I, Data_all_Acks, I) {
	j_sendUnblock;
    s_deallocateTBE;
	a_allocateRCC;
	setStatePF_IS_I;
	 kd_wakeUpDependents;
    o_popIncomingResponseQueue;


  }

  // directory is blocked when sending exclusive data
  transition(IS_I, RCC_Exclusive, E) {
    u_writeDataToL1Cache;
    hx_load_hit;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;
   a_allocateRCC; //David May1
setStateE;

    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	


  }

  // directory is blocked when sending exclusive data
  transition(PF_IS_I, RCC_Exclusive, E) {
    u_writeDataToL1Cache;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;

   a_allocateRCC; //David May1
	setStateE;

    o_popIncomingResponseQueue;
    kd_wakeUpDependents;

  }

  transition(IS, RCC_Exclusive, E) {
    u_writeDataToL1Cache;
    hx_load_hit;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;

   a_allocateRCC; //David May1
	setStateE;

    o_popIncomingResponseQueue;
    kd_wakeUpDependents;

  }

  transition(PF_IS, RCC_Exclusive, E) {
    u_writeDataToL1Cache;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;
    mp_markPrefetched;

   a_allocateRCC; //David May1
	setStateE;

    o_popIncomingResponseQueue;
    kd_wakeUpDependents;


  }

  // Transitions from IM
  transition(IM, Inv, I) {
    fi_sendInvAck;
    l_popRequestQueue;
  }

//David split transitions
  transition(PF_IM, Inv, I) {
    fi_sendInvAck;
    l_popRequestQueue;
  }

  transition(PF_SM, Inv, I) {
    fi_sendInvAck;
//David add
	a_splitRCC;

    l_popRequestQueue;


  }

  transition(IM, Data, SM) {
    u_writeDataToL1Cache;
    q_updateAckCount;
    o_popIncomingResponseQueue;
	setStateSM;
  }

  transition(PF_IM, Data, PF_SM) {
    u_writeDataToL1Cache;
    q_updateAckCount;
    o_popIncomingResponseQueue;
	setStatePF_SM;
  }


  transition(IM, Data_all_Acks, M) {
    u_writeDataToL1Cache;


    hhx_store_hit;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;


	setStateM;
  }

//David May1
 transition(IM, RCC_allocate, M) {
	  u_writeDataToL1Cache;
 hhx_store_hit;
    jj_sendExclusiveUnblock;
  s_deallocateTBE;
	//David add
	a_allocateRCC;  //Nirvedh mdfy (since I removed Davids allocate for  stores)
	setStateM;
   
	o_popIncomingResponseQueue;
	 kd_wakeUpDependents;

 }

  transition(PF_IM, RCC_allocate, M) {
      u_writeDataToL1Cache;
 	q_updateAckCount;
	a_allocateRCC;
	setStateM;

	o_popIncomingResponseQueue;

  }


  transition(PF_IM, Data_all_Acks, M) {
    u_writeDataToL1Cache;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;

	setStateM;
  }

  // transitions from SM
//David modify (no longer goes to IM)
  transition(SM, Inv, IM) {
    forward_eviction_to_cpu;
    fi_sendInvAck;
//David add
	a_splitRCC;

    dg_invalidate_sc;
    l_popRequestQueue;


  }

  transition({SM, IM, PF_SM, PF_IM}, Ack) {
    q_updateAckCount;
    o_popIncomingResponseQueue;
  }

  transition(SM, Ack_all, M) {
    jj_sendExclusiveUnblock;
    hhx_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	setStateM;
  }

  transition(PF_SM, Ack_all, M) {
    jj_sendExclusiveUnblock;
    s_deallocateTBE;
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	setStateM;
  }

  transition(SINK_WB_ACK, Inv){
    fi_sendInvAck;
    l_popRequestQueue;
  }

  transition(SINK_WB_ACK, WB_Ack, I){
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
	setStateI;
  }


//David added transitions
  transition({S,M,E}, RCC_HIT) {
	oo_allocateL1DCacheBlock;
    i_allocateTBE;
    uu_profileDataMiss;
    po_observeMiss;
	a_issueRCC_GET;
    k_popMandatoryQueue;

  }

  /*transition({NP,I}, RCC_HIT, IS) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    a_issueGETS;
    uu_profileDataMiss;
    po_observeMiss;
    k_popMandatoryQueue;
	setStateIS;

  }*/

  transition(S, RCC_Inv, I) {
    forward_eviction_to_cpu;
    fi_sendInvAck;
    l_popRequestQueue;
	setStateI;
  }

  transition(E, RCC_Inv, I) {
    // don't send data
    forward_eviction_to_cpu;
    fi_sendInvAck;
    l_popRequestQueue;
	setStateI;
  }

  transition(M, RCC_Inv, I) {
    forward_eviction_to_cpu;
    f_sendDataToL2;
    l_popRequestQueue;
	setStateI;
  }

  transition(IS, RCC_Inv, I) {
	fi_sendInvAck;
	l_popRequestQueue;
	setStateI;
  }

  transition(PF_IS, RCC_Inv, PF_IS_I) {
    fi_sendInvAck;
    l_popRequestQueue;
	setStatePF_IS_I;
  }

  transition(IM, RCC_Inv, I) {
    fi_sendInvAck;
    l_popRequestQueue;
	setStateI;
  }

  transition(PF_IM, RCC_Inv, I) {
    fi_sendInvAck;
    l_popRequestQueue;
	setStateI;
  }

  transition(SM, RCC_Inv, IM) {
	//Do nothing -- already did everything from prev steps, just change cache line, do not change permissions    
	forward_eviction_to_cpu;
    fi_sendInvAck;
    dg_invalidate_sc;
    l_popRequestQueue;
	setStateIM;
}
}
